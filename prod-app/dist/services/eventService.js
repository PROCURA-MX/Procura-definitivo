"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventService = void 0;
const client_1 = require("@prisma/client");
class EventService {
    constructor() {
        this.eventQueue = [];
        this.isProcessing = false;
        this.maxRetries = 3;
        this.retryDelay = 5000; // 5 segundos
        // üéØ SISTEMA DE LOCKS PARA EVITAR DUPLICADOS
        this.processingLocks = new Map();
        this.lockTimeout = 30000; // 30 segundos
        console.log('üèóÔ∏è [EventService] Constructor iniciado');
        this.prisma = new client_1.PrismaClient();
        console.log('üèóÔ∏è [EventService] PrismaClient creado');
        this.startProcessing();
        console.log('üèóÔ∏è [EventService] Procesamiento iniciado');
    }
    static getInstance() {
        console.log('üîç [EventService] getInstance() llamado');
        if (!EventService.instance) {
            console.log('üîç [EventService] Creando nueva instancia');
            EventService.instance = new EventService();
        }
        else {
            console.log('üîç [EventService] Usando instancia existente');
        }
        return EventService.instance;
    }
    async addEvent(event, data) {
        const eventId = `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const eventData = {
            id: eventId,
            event,
            data,
            timestamp: new Date(),
            retryCount: 0,
            maxRetries: this.maxRetries,
            status: 'pending'
        };
        this.eventQueue.push(eventData);
        console.log(`üéØ [EventService] Evento agregado: ${event} (ID: ${eventId})`);
        console.log(`üéØ [EventService] Datos del evento:`, JSON.stringify(data, null, 2));
        console.log(`üéØ [EventService] Cola actual: ${this.eventQueue.length} eventos`);
        // üéØ PROCESAR INMEDIATAMENTE SI NO EST√Å PROCESANDO
        if (!this.isProcessing) {
            console.log('üöÄ [EventService] Iniciando procesamiento inmediato...');
            setImmediate(() => this.startProcessing());
        }
        return eventId;
    }
    async startProcessing() {
        if (this.isProcessing)
            return;
        this.isProcessing = true;
        console.log('üöÄ [EventService] Iniciando procesamiento de eventos...');
        console.log(`üöÄ [EventService] Eventos en cola: ${this.eventQueue.length}`);
        try {
            while (this.eventQueue.length > 0) {
                const event = this.eventQueue.shift();
                if (!event)
                    continue;
                console.log(`üîÑ [EventService] Procesando evento: ${event.event} (ID: ${event.id})`);
                console.log(`üîÑ [EventService] Datos del evento:`, JSON.stringify(event.data, null, 2));
                try {
                    await this.processEvent(event);
                    console.log(`‚úÖ [EventService] Evento procesado exitosamente: ${event.event} (ID: ${event.id})`);
                }
                catch (error) {
                    console.error(`‚ùå [EventService] Error procesando evento ${event.id}:`, error);
                    await this.handleEventFailure(event);
                }
            }
        }
        finally {
            this.isProcessing = false;
            console.log('üîÑ [EventService] Ciclo de procesamiento completado');
            console.log(`üîÑ [EventService] Eventos restantes en cola: ${this.eventQueue.length}`);
        }
        // üéØ PROCESAR INMEDIATAMENTE SI HAY EVENTOS NUEVOS
        if (this.eventQueue.length > 0) {
            console.log('üîÑ [EventService] Hay eventos pendientes, procesando inmediatamente...');
            setImmediate(() => this.startProcessing());
        }
    }
    async processEvent(event) {
        console.log(`üîÑ [EventService] Procesando evento: ${event.event} (ID: ${event.id})`);
        event.status = 'processing';
        switch (event.event) {
            case 'IMMUNOTHERAPY_TREATMENT':
                await this.processImmunotherapyTreatment(event.data);
                break;
            default:
                throw new Error(`Evento no reconocido: ${event.event}`);
        }
        event.status = 'completed';
        console.log(`‚úÖ [EventService] Evento procesado exitosamente: ${event.event} (ID: ${event.id})`);
    }
    async processImmunotherapyTreatment(data) {
        // üéØ SISTEMA DE LOCKS PARA EVITAR DUPLICADOS
        const lockKey = `immunotherapy_${data.pacienteId}_${data.organizacionId || 'default'}`;
        if (this.processingLocks.get(lockKey)) {
            console.log('‚ö†Ô∏è [EventService] Expediente ya est√° siendo procesado para paciente:', data.pacienteId, '- Saltando duplicado');
            return;
        }
        // üéØ ACTIVAR LOCK
        this.processingLocks.set(lockKey, true);
        // üéØ LIMPIAR LOCK DESPU√âS DE TIMEOUT
        setTimeout(() => {
            this.processingLocks.delete(lockKey);
        }, this.lockTimeout);
        try {
            console.log('üè• [EventService] Iniciando procesamiento de tratamiento de inmunoterapia:', {
                pacienteId: data.pacienteId,
                userId: data.userId,
                tipoTratamiento: data.tipoTratamiento,
                subtipo: data.subtipo,
                unidades: data.unidades,
                dosis: data.dosis,
                alergenos: data.alergenos,
                tuvoReaccion: data.tuvoReaccion,
                descripcionReaccion: data.descripcionReaccion
            });
            const { ImmunotherapyService } = await Promise.resolve().then(() => __importStar(require('./immunotherapyService')));
            const immunotherapyService = ImmunotherapyService.getInstance();
            // Obtener organizaci√≥n del usuario
            const user = await this.prisma.usuario.findUnique({
                where: { id: data.userId },
                select: { organizacion_id: true }
            });
            if (!user?.organizacion_id) {
                throw new Error('Usuario no tiene organizaci√≥n asignada');
            }
            // üéØ SOLO CREAR/ACTUALIZAR EXPEDIENTE SI HAY DATOS REALES DE TRATAMIENTO
            // Verificar si hay datos espec√≠ficos de tratamiento (unidades, dosis, alergenos)
            console.log('üîç [EventService] DIAGN√ìSTICO DE DATOS RECIBIDOS:', {
                unidades: data.unidades,
                dosis: data.dosis,
                alergenos: data.alergenos,
                alergenosLength: data.alergenos ? data.alergenos.length : 0,
                tipoTratamiento: data.tipoTratamiento,
                subtipo: data.subtipo
            });
            const tieneDatosEspecificos = data.unidades > 0 || data.dosis > 0 || (data.alergenos && data.alergenos.length > 0);
            console.log('üîç [EventService] VALIDACI√ìN DE DATOS ESPEC√çFICOS:', {
                unidadesMayorCero: data.unidades > 0,
                dosisMayorCero: data.dosis > 0,
                alergenosConDatos: data.alergenos && data.alergenos.length > 0,
                tieneDatosEspecificos: tieneDatosEspecificos
            });
            if (!tieneDatosEspecificos) {
                console.log('‚ö†Ô∏è [EventService] No hay datos espec√≠ficos de tratamiento (unidades, dosis, alergenos), saltando creaci√≥n de expediente');
                return;
            }
            console.log('‚úÖ [EventService] Datos espec√≠ficos de tratamiento confirmados, procediendo con la creaci√≥n');
            // Crear/actualizar expediente solo si hay un tratamiento real
            const record = await immunotherapyService.createOrUpdateRecord({
                pacienteId: data.pacienteId || '',
                organizacionId: user.organizacion_id,
                fechaInicio: new Date(),
                editadoPor: data.userId
            });
            console.log('‚úÖ [EventService] Expediente de inmunoterapia creado/actualizado:', record.id);
            // üéØ CREAR LOG ENTRY COMPLETO DEL TRATAMIENTO
            if (record && record.id) {
                await this.createTreatmentLogEntry(record.id, data, user.organizacion_id);
                console.log('‚úÖ [EventService] Log entry del tratamiento creado exitosamente');
            }
        }
        catch (error) {
            console.error('‚ùå [EventService] Error procesando tratamiento de inmunoterapia:', error);
            throw error;
        }
        finally {
            // üéØ LIMPIAR LOCK AL TERMINAR
            this.processingLocks.delete(lockKey);
            console.log('üîì [EventService] Lock liberado para paciente:', data.pacienteId);
        }
    }
    // üéØ NUEVO M√âTODO PARA CREAR LOG ENTRIES COMPLETOS
    async createTreatmentLogEntry(recordId, treatmentData, organizacionId) {
        try {
            console.log('üìù [EventService] Creando log entry para tratamiento:', {
                recordId,
                tipoTratamiento: treatmentData.tipoTratamiento,
                subtipo: treatmentData.subtipo
            });
            // üéØ DIAGN√ìSTICO COMPLETO DE LOS DATOS RECIBIDOS
            console.log('üîç [EventService] DIAGN√ìSTICO COMPLETO - Datos recibidos:', {
                tipoTratamiento: treatmentData.tipoTratamiento,
                subtipo: treatmentData.subtipo,
                unidades: treatmentData.unidades,
                dosis: treatmentData.dosis,
                alergenos: treatmentData.alergenos,
                observaciones: treatmentData.observaciones,
                descripcionReaccion: treatmentData.descripcionReaccion,
                tuvoReaccion: treatmentData.tuvoReaccion
            });
            // üéØ DIAGN√ìSTICO ESPEC√çFICO DE ITEMS Y ALERGENOS
            console.log('üîç [EventService] DIAGN√ìSTICO DE ITEMS Y ALERGENOS:', {
                itemsLength: treatmentData.items?.length || 0,
                items: treatmentData.items,
                alergenosPrincipales: treatmentData.alergenos,
                primerItem: treatmentData.items?.[0],
                primerItemAlergenos: treatmentData.items?.[0]?.alergenos
            });
            // üéØ LOG DETALLADO DE REACCIONES EN EVENT SERVICE
            console.log('üîç [EventService] DIAGN√ìSTICO DE REACCIONES:', {
                tuvoReaccion: treatmentData.tuvoReaccion,
                descripcionReaccion: treatmentData.descripcionReaccion,
                tipoReaccion: typeof treatmentData.descripcionReaccion,
                esUndefined: treatmentData.descripcionReaccion === undefined,
                esNull: treatmentData.descripcionReaccion === null,
                esVacio: treatmentData.descripcionReaccion === '',
                longitud: treatmentData.descripcionReaccion?.length,
                keysCompletas: Object.keys(treatmentData)
            });
            // Determinar el tipo de tratamiento y subtipo
            let tipoTratamiento = 'INMUNOTERAPIA';
            let subtipo = 'TRATAMIENTO_GENERAL';
            let unidades = 0;
            let dosis = 0;
            let alergenos = [];
            let observaciones = '';
            let frascos = []; // üéØ AGREGADO: Variable para almacenar n√∫meros de frasco
            // üéØ L√ìGICA INTELIGENTE Y ROBUSTA PARA DETERMINAR TIPO DE TRATAMIENTO
            // PRIORIDAD 1: Usar tipoTratamiento del InventoryService (que ya viene espec√≠fico)
            if (treatmentData.tipoTratamiento && treatmentData.tipoTratamiento !== 'INMUNOTERAPIA') {
                subtipo = treatmentData.tipoTratamiento;
                unidades = treatmentData.unidades || 0;
                dosis = treatmentData.dosis || 1;
                alergenos = treatmentData.alergenos || [];
                // üéØ CAPTURAR REACCIONES SI EXISTEN
                let reaccionInfo = '';
                if (treatmentData.tuvoReaccion && treatmentData.descripcionReaccion) {
                    reaccionInfo = ` | Reacci√≥n: ${treatmentData.descripcionReaccion}`;
                }
                observaciones = `${treatmentData.tipoTratamiento} - ${unidades} unidades, ${dosis} dosis${reaccionInfo}`;
            }
            // üéØ DIAGN√ìSTICO DE SUBTIPO
            console.log('üîç [eventService] DIAGN√ìSTICO DE SUBTIPO:', {
                subtipo: treatmentData.subtipo,
                tipoTratamiento: treatmentData.tipoTratamiento,
                subtipoType: typeof treatmentData.subtipo,
                esGLICERINADO_FRASCO: treatmentData.subtipo === 'GLICERINADO_FRASCO',
                esGLICERINADO_EN_FRASCO: treatmentData.subtipo === 'GLICERINADO_EN_FRASCO',
                condicion1: treatmentData.subtipo === 'GLICERINADO_FRASCO',
                condicion2: treatmentData.subtipo === 'GLICERINADO_EN_FRASCO',
                condicionCompleta: (treatmentData.subtipo === 'GLICERINADO_FRASCO' || treatmentData.subtipo === 'GLICERINADO_EN_FRASCO')
            });
            // PRIORIDAD 2: L√≥gica espec√≠fica por tipo (ANTES de la l√≥gica gen√©rica)
            if (treatmentData.subtipo === 'GLICERINADO_UNIDAD' || treatmentData.subtipo === 'GLICERINADO_POR_UNIDAD') {
                subtipo = 'GLICERINADO_UNIDAD';
                unidades = treatmentData.unidades || 0;
                dosis = treatmentData.dosis || 1;
                alergenos = treatmentData.alergenos || [];
                const frascoType = treatmentData.frascoType || 'Madre';
                observaciones = `Glicerinado por Unidad - ${unidades} unidades, ${dosis} dosis, Frasco: ${frascoType}`;
            }
            else if (treatmentData.subtipo === 'GLICERINADO_FRASCO' || treatmentData.subtipo === 'GLICERINADO_EN_FRASCO') {
                console.log('üéØ [eventService] ¬°CONDICI√ìN CUMPLIDA! Entrando a GLICERINADO_FRASCO');
                console.log('üîç [eventService] Recibiendo treatmentData para GLICERINADO_FRASCO:', treatmentData);
                subtipo = 'GLICERINADO_EN_FRASCO';
                unidades = treatmentData.unidades || 0;
                // üéØ EXTRAER N√öMEROS DE FRASCO DEL CAMPO FRASCO
                frascos = []; // Usar la variable del scope superior
                dosis = 1;
                // üö® DIAGN√ìSTICO COMPLETO DE ITEMS
                console.log('üîç [eventService] DIAGN√ìSTICO COMPLETO DE ITEMS:', {
                    itemsExists: !!treatmentData.items,
                    itemsLength: treatmentData.items?.length || 0,
                    items: treatmentData.items,
                    primerItem: treatmentData.items?.[0],
                    primerItemKeys: treatmentData.items?.[0] ? Object.keys(treatmentData.items[0]) : [],
                    primerItemFrasco: treatmentData.items?.[0]?.frasco,
                    primerItemFrascoType: typeof treatmentData.items?.[0]?.frasco
                });
                if (treatmentData.items && treatmentData.items.length > 0) {
                    const frascoField = treatmentData.items[0].frasco;
                    console.log('üîç [eventService] Campo frasco para GLICERINADO_FRASCO:', frascoField);
                    console.log('üîç [eventService] Tipo de frascoField:', typeof frascoField);
                    console.log('üîç [eventService] frascoField includes Frascos:', frascoField?.includes('Frascos:'));
                    if (frascoField && frascoField.includes('Frascos:')) {
                        // Extraer n√∫meros de frasco del formato "Frascos: 1, 2"
                        const frascoNumbers = frascoField.replace('Frascos:', '').trim().split(',').map((f) => f.trim());
                        frascos = frascoNumbers;
                        console.log('üîç [eventService] Frascos extra√≠dos:', frascos);
                        // üéØ LAS DOSIS VIENEN DEL CAMPO DOSIS, NO DEL N√öMERO DE FRASCOS
                        dosis = treatmentData.dosis || 1;
                        console.log('üîç [eventService] Dosis del formulario:', dosis);
                    }
                    else if (frascoField) {
                        // Si es un solo n√∫mero
                        const match = frascoField.match(/\d+/);
                        if (match) {
                            frascos = [match[0]];
                            dosis = treatmentData.dosis || 1;
                            console.log('üîç [eventService] Frasco √∫nico extra√≠do:', frascos);
                        }
                    }
                    else {
                        console.log('üîç [eventService] ‚ùå frascoField es null/undefined/vac√≠o');
                    }
                }
                else {
                    console.log('üîç [eventService] ‚ùå No hay items o items est√° vac√≠o');
                }
                alergenos = treatmentData.alergenos || [];
                observaciones = `Glicerinado en Frasco - Frascos: ${frascos.join(', ')}, ${dosis} dosis`;
            }
            else if (treatmentData.subtipo === 'SUBLINGUAL') {
                console.log('üîç [eventService] Recibiendo treatmentData para SUBLINGUAL:', treatmentData); // <-- NUEVO LOG
                subtipo = 'SUBLINGUAL';
                unidades = treatmentData.unidades || 0;
                dosis = treatmentData.dosis || 1;
                alergenos = treatmentData.alergenos || [];
                // üéØ EXTRAER N√öMERO DE FRASCO DEL PRODUCTID
                let frascoNum = '1'; // Por defecto
                if (treatmentData.items && treatmentData.items.length > 0) {
                    const productId = treatmentData.items[0].productId;
                    const frascoMatch = productId.match(/#(\d+)/);
                    if (frascoMatch) {
                        frascoNum = frascoMatch[1];
                    }
                }
                observaciones = `Sublingual - Frasco ${frascoNum}, ${dosis} dosis`;
            }
            else if (treatmentData.subtipo && treatmentData.subtipo.startsWith('ALXOID_')) {
                subtipo = treatmentData.subtipo; // üéØ CORREGIDO: Mantener el subtipo espec√≠fico (ALXOID_A, ALXOID_B, ALXOID_B.2)
                unidades = treatmentData.unidades || 0;
                dosis = treatmentData.dosis || 1;
                alergenos = treatmentData.alergenos || [];
                observaciones = `${treatmentData.subtipo} - ${unidades} unidades, ${dosis} dosis`;
            }
            // PRIORIDAD 3: Usar subtipo gen√©rico si existe
            else if (treatmentData.subtipo && treatmentData.subtipo !== 'TRATAMIENTO_GENERAL') {
                subtipo = treatmentData.subtipo;
                unidades = treatmentData.unidades || 0;
                dosis = treatmentData.dosis || 1;
                alergenos = treatmentData.alergenos || [];
                observaciones = `${treatmentData.subtipo} - ${unidades} unidades, ${dosis} dosis`;
            }
            else {
                // üéØ TRATAMIENTO GEN√âRICO CON TODOS LOS DATOS DISPONIBLES
                subtipo = treatmentData.tipoTratamiento || treatmentData.subtipo || 'TRATAMIENTO_GENERAL';
                unidades = treatmentData.unidades || 0;
                dosis = treatmentData.dosis || 1;
                alergenos = treatmentData.alergenos || [];
                observaciones = treatmentData.observaciones || `Tratamiento de inmunoterapia - ${unidades} unidades, ${dosis} dosis`;
            }
            // üéØ LOG DEL TIPO DE TRATAMIENTO DETERMINADO
            console.log('üéØ [EventService] Tipo de tratamiento determinado:', {
                tipoTratamiento,
                unidades,
                dosis,
                alergenos: alergenos.length,
                observaciones
            });
            // üéØ CAPTURAR REACCIONES COMPLETAS
            let descripcionReaccion = '';
            if (treatmentData.tuvoReaccion && treatmentData.descripcionReaccion) {
                descripcionReaccion = treatmentData.descripcionReaccion;
            }
            // üéØ EXTRAER N√öMERO DE FRASCO PARA SUBLINGUAL (GLICERINADO_EN_FRASCO ya se proces√≥ arriba)
            if (subtipo === 'SUBLINGUAL') {
                if (treatmentData.items && treatmentData.items.length > 0) {
                    const productId = treatmentData.items[0].productId;
                    const frascoMatch = productId.match(/#(\d+)/);
                    if (frascoMatch) {
                        frascos = [frascoMatch[1]];
                    }
                    else {
                        frascos = ['1']; // Por defecto
                    }
                }
                else {
                    frascos = ['1']; // Por defecto
                }
            }
            // NOTA: GLICERINADO_EN_FRASCO ya se proces√≥ en la l√≥gica espec√≠fica arriba
            // üéØ CREAR LOG ENTRY COMPLETO Y DETALLADO EN LA BASE DE DATOS
            const logEntryData = {
                recordId: recordId,
                fechaAplicacion: new Date(), // ‚úÖ CORREGIDO: Usar fechaAplicacion (campo correcto del esquema)
                tipoTratamiento: tipoTratamiento, // ‚úÖ CORREGIDO: Cast para evitar error de tipo
                subtipo: subtipo, // üéØ AGREGADO: Incluir subtipo
                productId: treatmentData.items?.[0]?.productId || null, // üéØ AGREGADO: Incluir productId para trazabilidad
                dosis: dosis.toString(), // ‚úÖ CORREGIDO: Convertir a String (esquema espera String)
                unidades: parseInt(unidades.toString()) || 0, // ‚úÖ CORREGIDO: Convertir a Int (esquema espera Int)
                frascos: frascos, // üéØ AGREGADO: Incluir frascos
                alergenos: alergenos, // ‚úÖ CORREGIDO: Campo correcto del esquema
                descripcionReaccion: descripcionReaccion, // ‚úÖ CORREGIDO: Campo correcto del esquema
                reaccion: treatmentData.tuvoReaccion || false, // ‚úÖ CORREGIDO: Usar 'reaccion' (campo correcto del esquema)
                observaciones: observaciones || 'Tratamiento de inmunoterapia aplicado', // ‚úÖ CORREGIDO: Campo correcto del esquema
                userId: treatmentData.userId // ‚úÖ CORREGIDO: Campo correcto del esquema
            };
            // üéØ LOG ESPEC√çFICO PARA DIAGNOSTICAR FRASCOS
            console.log('üîç [EventService] DIAGN√ìSTICO DE FRASCOS ANTES DE GUARDAR:', {
                subtipo,
                frascos,
                frascosLength: frascos.length,
                frascosType: typeof frascos,
                productId: treatmentData.items?.[0]?.productId
            });
            // üéØ AGREGAR INFORMACI√ìN ADICIONAL PARA TRAZABILIDAD COMPLETA
            if (treatmentData.inventoryUsageId) {
                logEntryData.inventoryUsageId = treatmentData.inventoryUsageId;
            }
            // Obtener informaci√≥n adicional del InventoryUsage si est√° disponible
            if (treatmentData.inventoryUsageId) {
                try {
                    const inventoryUsage = await this.prisma.inventoryUsage.findUnique({
                        where: { id: treatmentData.inventoryUsageId },
                        select: {
                            consultorioId: true,
                            sedeId: true,
                            observaciones: true
                        }
                    });
                    if (inventoryUsage) {
                        // Enriquecer las observaciones con informaci√≥n del consultorio y sede
                        if (inventoryUsage.observaciones) {
                            logEntryData.observaciones += ` | ${inventoryUsage.observaciones}`;
                        }
                    }
                }
                catch (error) {
                    console.warn('‚ö†Ô∏è [EventService] No se pudo obtener informaci√≥n adicional del InventoryUsage:', error);
                }
            }
            // ‚úÖ CORREGIDO: Usar los campos correctos del esquema real de la base de datos
            const logEntryToCreate = {
                recordId: logEntryData.recordId,
                fechaAplicacion: new Date(),
                tipoTratamiento: 'INMUNOTERAPIA',
                subtipo: subtipo, // üÜï AGREGAR SUBTIPO
                productId: logEntryData.productId, // üéØ AGREGADO: Incluir productId
                dosis: (parseFloat(logEntryData.dosis) || 1).toString(), // ‚úÖ CORREGIDO: Convertir a String
                unidades: parseInt(unidades.toString()) || 0, // ‚úÖ CORREGIDO: Convertir a Int
                frascos: frascos, // üéØ AGREGADO: Incluir frascos
                alergenos: logEntryData.alergenos,
                descripcionReaccion: logEntryData.descripcionReaccion,
                reaccion: logEntryData.reaccion, // ‚úÖ CORREGIDO: Usar 'reaccion' (campo correcto del esquema)
                observaciones: logEntryData.observaciones, // ‚úÖ CORREGIDO: Usar 'observaciones' directamente
                userId: logEntryData.userId
            };
            await this.prisma.immunotherapyLog.create({
                data: logEntryToCreate
            });
            console.log('‚úÖ [EventService] Log entry creado exitosamente con datos:', {
                subtipo,
                unidades,
                dosis,
                alergenos: alergenos.length,
                observaciones,
                descripcionReaccion: logEntryData.descripcionReaccion,
                reaccion: treatmentData.tuvoReaccion || false
            });
            // üéØ LOG COMPLETO DE LO QUE SE GUARD√ì EN LA BASE DE DATOS
            console.log('üéØ [EventService] DATOS COMPLETOS GUARDADOS EN BD:', JSON.stringify(logEntryData, null, 2));
        }
        catch (error) {
            console.error('‚ùå [EventService] Error creando log entry del tratamiento:', error);
            // NO lanzar error aqu√≠ para no fallar todo el proceso
            // Solo loggear el error para debugging
        }
    }
    async handleEventFailure(event) {
        event.retryCount++;
        if (event.retryCount >= event.maxRetries) {
            event.status = 'failed';
            event.error = 'M√°ximo de reintentos alcanzado';
            console.error(`üíÄ [EventService] Evento fall√≥ permanentemente: ${event.event} (ID: ${event.id})`);
        }
        else {
            event.status = 'pending';
            // Reintentar despu√©s del delay
            setTimeout(() => {
                this.eventQueue.unshift(event);
            }, this.retryDelay * event.retryCount);
            console.log(`üîÑ [EventService] Reintentando evento: ${event.event} (ID: ${event.id}) - Intento ${event.retryCount}`);
        }
    }
    getQueueStatus() {
        return {
            totalEvents: this.eventQueue.length,
            isProcessing: this.isProcessing,
            pendingEvents: this.eventQueue.filter(e => e.status === 'pending').length,
            completedEvents: this.eventQueue.filter(e => e.status === 'completed').length,
            failedEvents: this.eventQueue.filter(e => e.status === 'failed').length
        };
    }
}
exports.EventService = EventService;
